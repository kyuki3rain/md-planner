# パッチサービスコンポーネント詳細設計

## 1. 目的
- ビューからの編集操作をMarkdownファイルへ最小差分で反映し、整形を崩さずに更新する。

## 2. コンポーネント構造
- `PatchService`: 公開API。タスク属性更新や挿入/削除のインターフェース。
- `PatchPlanner`: AST/トークン列から最小差分を計算。
- `PatchApplier`: VS Code `workspace.applyEdit`をラップし適用。
- `ConflictResolver`: 競合検出とリトライ (設定`preferNewest`)。
- `FormatterBridge`: ユーザー設定の整形ツールに委譲するラッパー。

## 3. 主なAPI
```
interface PatchService {
  applyTaskMutation(taskId: string, mutation: TaskMutation): Promise<void>;
  createTask(fileUri: Uri, payload: NewTaskPayload, position: InsertPosition): Promise<string>;
  deleteTask(taskId: string): Promise<void>;
  bulkUpdate(mutations: TaskMutation[]): Promise<void>;
}
```
- `TaskMutation`: `{ path: AttributePath, value: any, type: 'set'|'unset'|'toggle' }`
- `NewTaskPayload`: タスクテンプレート (タイトル、属性、ステータス)。

## 4. パッチ生成フロー
1. ビューで操作 → ドメインイベント (例: `status`更新)。
2. `PatchService.applyTaskMutation`呼び出し。
3. `PatchPlanner`が`TaskRecord`と最新ファイル内容を取得。
4. 変更対象行/属性を特定し、最小差分 (インライン置換/属性ブロック再構成) を生成。
5. `PatchApplier`が`WorkspaceEdit`を作成し適用。
6. 成功後`TaskIndexService.refreshTask`で再解析。

## 5. 差分戦略
- チェックボックス行: `- [ ]`と属性ブロック内のターゲット属性のみを変更。
- インライン関数記法: `@due(...)`などを正規表現で置換。複数記法が混在する場合は優先順位を設定 (属性ブロック > 関数記法)。
- 改行/インデント保持: 元のスペースと折返しを記録して再利用。

## 6. 競合処理
- 適用前に`FileMetadataStore.version`と比較。
- 差異がある場合は再パースして再計算 (最大3回試行)。
- それでも競合ならユーザーへ通知し、マージビューアを開くオプション。

## 7. バリデーション
- `TaskMutationValidator`で属性値の型/フォーマットを検証。
- `start/due`などの日付整合性は事前検証。失敗した場合は適用前にエラー。

## 8. Undo/Redo
- VS Codeの標準Undoに依存。`WorkspaceEdit`をまとめて適用することで一操作に集約。

## 9. エラーハンドリング
- ファイル書込み失敗時: リトライ + エラートースト。
- プランナー失敗 (構文解析不整合): タスクをリードオンリー扱いにし、ユーザーへハイライト。

## 10. テスト戦略
- スナップショットテスト: 変更前後のMarkdown比較。
- 並行編集シナリオ: ファイル更新中にパッチを適用するケース。
- 属性追加/削除/複合記法のユニットテスト。
